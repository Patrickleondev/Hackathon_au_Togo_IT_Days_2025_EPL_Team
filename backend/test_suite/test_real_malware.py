"""
Test d'analyse du vrai malware ircbot
RansomGuard AI - Hackathon Togo IT Days 2025
"""

import asyncio
import os
import logging
from ml_engine.hybrid_detector import HybridDetector
from ml_engine.ransomware_detector import RansomwareDetector
from ml_engine.huggingface_detector import HuggingFaceDetector
from ml_engine.advanced_detector import AdvancedHuggingFaceDetector

# Configuration du logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def analyze_real_malware():
    """Analyser le vrai fichier ircbot malveillant"""
    try:
        logger.info("üß™ Analyse du vrai malware ircbot...")
        
        # Chemin vers le fichier ircbot
        ircbot_path = "../ircbot"
        
        if not os.path.exists(ircbot_path):
            logger.error(f"‚ùå Fichier ircbot non trouv√©: {ircbot_path}")
            return
        
        logger.info(f"üìÅ Fichier trouv√©: {ircbot_path}")
        logger.info(f"üìä Taille: {os.path.getsize(ircbot_path)} bytes")
        
        # Test 1: Analyse avec le d√©tecteur hybride
        logger.info("üîç Test 1: Analyse hybride")
        hybrid_detector = HybridDetector()
        await hybrid_detector.initialize()
        
        result = await hybrid_detector.analyze_file_hybrid(
            ircbot_path, 
            {"filename": "ircbot", "upload_source": "real_malware_test"}
        )
        
        logger.info(f"R√©sultat hybride: {result}")
        logger.info(f"Menace d√©tect√©e: {result.get('is_threat', False)}")
        logger.info(f"Confiance: {result.get('confidence', 0.0):.2f}")
        logger.info(f"Type: {result.get('threat_type', 'unknown')}")
        
        # Test 2: Analyse directe avec chaque d√©tecteur
        logger.info("üîç Test 2: Analyse individuelle des d√©tecteurs")
        
        # D√©tecteur traditionnel
        traditional_detector = RansomwareDetector()
        features = await traditional_detector.extract_features(ircbot_path, {})
        logger.info(f"Features extraites: {features.shape if hasattr(features, 'shape') else len(features)}")
        
        # D√©tecteur NLP
        nlp_detector = HuggingFaceDetector()
        nlp_result = await nlp_detector.analyze_with_huggingface(ircbot_path, {})
        logger.info(f"R√©sultat NLP: {nlp_result}")
        
        # D√©tecteur avanc√©
        advanced_detector = AdvancedHuggingFaceDetector()
        advanced_result = await advanced_detector.analyze_with_advanced_detector(ircbot_path, {})
        logger.info(f"R√©sultat avanc√©: {advanced_result}")
        
        # Test 3: Analyse des patterns suspects
        logger.info("üîç Test 3: Analyse des patterns suspects")
        
        # Lire les premiers bytes du fichier
        with open(ircbot_path, 'rb') as f:
            header = f.read(1024)
        
        logger.info(f"Header (hex): {header[:32].hex()}")
        
        # Chercher des patterns suspects
        suspicious_patterns = [
            b'PE\x00\x00',  # Header PE
            b'MZ',          # Header MZ
            b'CreateFile', b'ReadFile', b'WriteFile',
            b'RegCreateKey', b'RegSetValue',
            b'InternetOpen', b'HttpOpenRequest',
            b'CryptEncrypt', b'CryptDecrypt',
            b'payload', b'malware', b'virus',
            b'encrypt', b'decrypt', b'ransomware'
        ]
        
        found_patterns = []
        for pattern in suspicious_patterns:
            if pattern in header:
                found_patterns.append(pattern.decode('utf-8', errors='ignore'))
        
        logger.info(f"Patterns suspects trouv√©s: {found_patterns}")
        
        # Test 4: Analyse de l'entropie
        logger.info("üîç Test 4: Analyse de l'entropie")
        
        def calculate_entropy(data):
            if not data:
                return 0.0
            
            import math
            byte_counts = [0] * 256
            for byte in data:
                byte_counts[byte] += 1
            
            entropy = 0.0
            data_length = len(data)
            
            for count in byte_counts:
                if count > 0:
                    probability = count / data_length
                    entropy -= probability * math.log2(probability)
            
            return entropy
        
        entropy = calculate_entropy(header)
        logger.info(f"Entropie: {entropy:.2f}")
        
        # D√©terminer si c'est un binaire
        is_binary = header.startswith(b'MZ') or header.startswith(b'PE') or header.startswith(b'\x7fELF')
        logger.info(f"Est un binaire: {is_binary}")
        
        # Chercher des patterns sp√©cifiques aux binaires ELF
        elf_patterns = [
            b'CreateFile', b'ReadFile', b'WriteFile', b'DeleteFile',
            b'RegCreateKey', b'RegSetValue', b'RegDeleteValue',
            b'InternetOpen', b'HttpOpenRequest', b'HttpSendRequest',
            b'CryptEncrypt', b'CryptDecrypt', b'CryptGenKey',
            b'ShellExecute', b'WinExec', b'CreateProcess',
            b'VirtualAlloc', b'VirtualProtect', b'WriteProcessMemory',
            b'CreateRemoteThread', b'SetWindowsHookEx',
            b'GetSystemDirectory', b'GetWindowsDirectory',
            b'FindFirstFile', b'FindNextFile',
            b'CopyFile', b'MoveFile', b'SetFileAttributes',
            # Patterns Linux/ELF
            b'execve', b'fork', b'clone', b'kill',
            b'open', b'read', b'write', b'close',
            b'socket', b'connect', b'bind', b'listen',
            b'accept', b'send', b'recv',
            b'chmod', b'chown', b'unlink', b'rename',
            b'system', b'popen', b'getenv', b'setenv',
            b'malloc', b'free', b'mmap', b'munmap',
            b'ptrace', b'prctl', b'seccomp',
            b'payload', b'malware', b'virus', b'backdoor',
            b'encrypt', b'decrypt', b'ransomware', b'botnet'
        ]
        
        found_elf_patterns = []
        for pattern in elf_patterns:
            if pattern in header:
                found_elf_patterns.append(pattern.decode('utf-8', errors='ignore'))
        
        logger.info(f"Patterns ELF suspects trouv√©s: {found_elf_patterns}")
        
        # Conclusion
        logger.info("üìä CONCLUSION DE L'ANALYSE:")
        logger.info(f"  ‚Ä¢ Fichier: {ircbot_path}")
        logger.info(f"  ‚Ä¢ Taille: {os.path.getsize(ircbot_path)} bytes")
        logger.info(f"  ‚Ä¢ Est binaire: {is_binary}")
        logger.info(f"  ‚Ä¢ Type: ELF (Linux)")
        logger.info(f"  ‚Ä¢ Patterns suspects: {len(found_elf_patterns)}")
        logger.info(f"  ‚Ä¢ Menace d√©tect√©e: {result.get('is_threat', False)}")
        logger.info(f"  ‚Ä¢ Confiance: {result.get('confidence', 0.0):.2f}")
        
        if result.get('is_threat', False):
            logger.info("‚úÖ MALWARE D√âTECT√â!")
        else:
            logger.warning("‚ö†Ô∏è MALWARE NON D√âTECT√â - Am√©lioration n√©cessaire")
        
    except Exception as e:
        logger.error(f"‚ùå Erreur lors de l'analyse: {e}")
        raise

async def main():
    """Fonction principale"""
    logger.info("üöÄ D√©marrage de l'analyse du vrai malware ircbot...")
    await analyze_real_malware()
    logger.info("üéØ Analyse termin√©e!")

if __name__ == "__main__":
    asyncio.run(main())
